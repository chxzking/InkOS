#pragma once
#ifndef INKOS_H
#define INKOS_H

#include "inkos_config.h"

#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <math.h>

#include "stm32f10x.h"   

//【标准版说明：】
/**************************
标准版属于精简系统，仅仅配备
了InkOS2.0的所有核心功能，不
具备图形界面
***************************/

/*****************************************************************
 ___         _      ___   ____  
|_ _| _ __  | | __ / _ \ / ___| 
 | | | '_ \ | |/ /| | | |\___ \ 		作者：红笺画文
 | | | | | ||   < | |_| | ___) |		 
|___||_| |_||_|\_\ \___/ |____/			时间：2024年6月2日

*******************************************************************/

/***********************************************************************

InkOS2.0是重构了整个内核，与InkOS1.0相比有巨大的飞跃。
【任务内核架构：】
[InkOS1.0]：
（1）采用了“字典模型”，即使用了目录与内容分治的思想，目录用于记载所有的软件
信息，当软件被调用时，内核立即依据目录的信息申请开辟空间，加入任务执行环等待
执行。
[InkOS2.0]：
采用了新的“唱片机模型”
（1）依旧采用分治思想，在保留“字典模型”高效的同时引入了优先级，字典模型虽然能高效
的利用空间运行任务，但是不支持优先级操作。同一个优先级任务将会连接成一个环，即“唱片”。
（2）合并了目录与内容成为一个唱片区域，将TCB从任务中独立出去，支持了自定义堆栈大小，
只有任务启用时，TCB才会分配空间，从而能在相同容量的内存中，运行远超其容量的任务
（3）新增任务配置策略，当任务容量占满时申请任务加入InkOS2.0提供了三种策略
（4）新增SPC概念，用于在优先级不同的任务之间切换
【CPU及内存控制】
[InkOS1.0]：
（1）采用了单内存池，支持自定义内存池大小
（2）提供CPU利用率统计接口
[InkOS2.0]：
采用双内存池架构
（1）采用双内存池架构，支持自定义内存池大小的同时分离了任务内存与用户内存，避免了用户与
系统内存之间的相互干扰
（2）移除了CPU统计接口，经过测试，Inkos2.0的CPU利用率几乎在99%的水平，因为内核模型优化，
大大减少了IO的时间浪费，所以CPU统计已经没有了实际的作用，最终决定移除
【其他】
[InkOS1.0]：
（1）作为实验性的第一代，几乎没有提供定制功能
[InkOS2.0]：
（2）提供了大量的定制功能，并在inkos配置文件提供了统一的接口。

PS：文件底部提供了“唱片机模型”示意图，缩小观看示意图获得最佳体验
************************************************************************/


//核心结构声明
enum Stack_Overflow_t{/*栈溢出信号类型*/
	STACK_OVERFLOW = -1,//栈溢出
	STACK_SAFETY = 0,	//栈安全
	STACK_FULL = 1		//栈满（处于溢出边界）
};

typedef struct TASK_ORBIT_RING TASK_ORBIT_RING;				                    //定义任务轨道环（句柄）
typedef struct SCHEDULING_PRIORITY_CHAIN SCHEDULING_PRIORITY_CHAIN;             //任务计划链
typedef struct INSPECTOR INSPECTOR;                                             //巡查员
typedef enum Stack_Overflow_t Stack_Overflow_t;									//栈溢出信号类型

//数据类型重定义
typedef void (*TASK_FUNCTION)(void*);							                //任务函数
typedef STACK_DEPTH_TYPE StackDepth;                                            //栈的深度重定义
typedef unsigned short DYNAMIC_MEMORY_TYPE; 									//重定义一个统一的动态内存分配类型

//核心变量
extern Stack_Overflow_t STACK_OVERFLOW_FLAG;									//栈溢出信号（当该变量为非零状态，则表示堆栈溢出）


/*******************
*  任务内核创建与加载
*******************/

//操作系统初始化
int Inkos_Init(void);
//操作系统启动，请将函数放置在main函数中的末尾或者while(1)之前
void Inkos_StartUp(void);

/*******************
*  任务创建与加载
*******************/
/*
【创建一个新任务】
（只增加任务信息，不开辟堆栈）
建议所有的任务都在main函数中创建，因为创建任务的性能开销较大，最好的方式是提前声明任务
[参数：]
taskFunction	-->任务函数，标准形式为void func(void*args)
Args			-->任务函数的参数，如果没有参数，请填写NULL
Priority		-->任务优先级，优先级分为0-15，数字越大优先级越高
icon			-->任务的logo，如果没有可填写NULL
Task_name		-->任务的名称，任务名具有唯一性，作为任务的唯一标识，可以通过任务名查找任务句柄，不能填写为NULL，
size			-->任务堆栈大小的设置
*/
int Task_Create(TASK_FUNCTION taskFunction,void* Args,unsigned char Priority,unsigned char* icon,char* Task_name,StackDepth size);
#if SPECIAL_PRIORITY_CONFIG	== SPECIAL_PRIORITY_ENABLE
/*
【创建一个特殊优先级的新任务】
（只增加任务信息，不开辟堆栈，此任务独立于所有优先级之外，与优先级任务交替执行）
（1）建议所有的任务都在main函数中创建，因为创建任务的性能开销较大，最好的方式是提前声明任务
（2）默认策略中该函数处于关闭状态，该函数在一定程度上会影响到系统的性能。

[参数：]
taskFunction	-->任务函数，标准形式为void func(void*args)
Args			-->任务函数的参数，如果没有参数，请填写NULL
icon			-->任务的logo，如果没有可填写NULL
Task_name		-->任务的名称，任务名具有唯一性，作为任务的唯一标识，可以通过任务名查找任务句柄，不能填写为NULL，
size			-->任务堆栈大小的设置
[返回值]

*/
int Special_Priority_Task_Create(TASK_FUNCTION taskFunction,void* Args,unsigned char* icon,char* Task_name,StackDepth size);
#endif
/*
【任务加载】
（1）启用任务，开辟任务堆栈
（2）该函数可以在任何地方使用，用于真正开启任务
（3）在不知道任务句柄的情况下通常与Task_Find连用通过任务名称开启任务
[参数：]
TOR				-->任务节点的句柄
*/
//任务加载
int Task_Load(TASK_ORBIT_RING* TOR);

 /**********************
*  任务挂起、终止与唤醒
************************/
//任务挂起
/*
 【挂起当前任务】
 (1)在任务自身调用，可迅速将任务自身挂起
*/
 void Task_Suspended(void);
/*
 【挂起指定任务】
 (1)可迅速将指定任务挂起
（2）在不知道任务句柄的情况下通常与Task_Find连用通过任务名称挂起任务
[参数：]
TOR				-->任务节点的句柄
*/
 int Task_Suspended_Designated(TASK_ORBIT_RING* TOR);
/*
 【唤醒指定任务】
 (1)可迅速将指定任务挂起
（2）在不知道任务句柄的情况下通常与Task_Find连用通过任务名称唤醒任务
[参数：]
TOR				-->任务节点的句柄
*/
 int Task_Wake(TASK_ORBIT_RING* TOR);
/*
 【终止任务】
 (1)可迅速将自身任务终止，任务将立刻释放堆区空间
*/
 int Task_Exit(void);//结束当前任务
/*
 【终止指定任务】
 (1)可迅速将指定任务挂起
（2）在不知道任务句柄的情况下通常与Task_Find连用通过任务名称终止任务
[参数：]
TOR				-->任务节点的句柄
*/
 int Task_Exit_Designated(TASK_ORBIT_RING* TOR);//结束指定任务

/***************************
*  任务优先级修改与句柄查找
****************************/
/*
 【修改指定任务优先级】
（1）修改指定任务的优先级
（2）在不知道任务句柄的情况下通常与Task_Find连用通过任务名称唤醒任务
[参数：]
TOR				-->任务节点的句柄
Priority		-->目标优先级
*/
int Task_Priority_Modify(TASK_ORBIT_RING* TOR, unsigned char Priority);
/*
 【获取指定任务的句柄】
（1）通过任务名快速获取指定任务的句柄
（2）该任务的底层是哈希表，所以效率很高，对系统的性能几乎没有影响
[参数：]
Task_Name		-->任务的名称
*/
TASK_ORBIT_RING* Task_Find(char* Task_Name);
/*
 【获取当前任务的句柄】
（1）快速获取当前任务的句柄
*/
TASK_ORBIT_RING* Task_Current_Handle(void);

/***************************
*  任务切换器
****************************/
 //用户主动触发器
#define User_Initiated_Switch_Trigger()   SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk

//重置时间片计时
#define Reset_Time_Slice_Timing()	SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;\
									SysTick->VAL = 0;\
									SysTick->CTRL |= SysTick_CTRL_ENABLE_Msk

//开始任务调度器
#define	Open_Task_Scheduler()	SysTick->VAL = 0;\
								SysTick->CTRL |= SysTick_CTRL_ENABLE_Msk

//关闭任务调度器
#define	Close_Task_Scheduler()	SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk


/***************************
*  进程同步
****************************/
typedef struct Mutex_t Mutex_t;														//互斥锁	
typedef struct Semaphore_t Semaphore_t;												//计数信号量


//函数
/*
 【互斥锁初始化】
（1）该函数会在堆区初始化互斥锁
（2）该函数只能在main中调用，否则可能引发未定义错误
*/
Mutex_t* Mutex_Init(void);															//互斥锁初始化
/*
 【非阻塞型互斥锁】
（1）该函数在无法获取到互斥锁时会立刻继续执行
[参数：]
Mutex			-->互斥锁指针
*/
int Mutex_Lock_Non_Blocking(Mutex_t* Mutex);										//非阻塞型互斥锁
/*
 【阻塞型互斥锁】
（1）该函数在无法获取到互斥锁时会进入等待
（2）可以设置等待时间，时间以时间片为单位，比如等待1时间片
[参数：]
Mutex			-->互斥锁指针
Block_Time		-->设置时间，当时间设置为0时，该函数将永久阻塞
*/
int Mutex_Lock(Mutex_t* Mutex,unsigned int Block_Time);								//阻塞型互斥锁
/*
 【解锁互斥锁】
（1）该函数在释放互斥锁，注意只有互斥锁的所有者才能释放互斥锁
[参数：]
Mutex			-->互斥锁指针
*/
int Mutex_Unlock(Mutex_t* Mutex);													//互斥锁解锁


/*
 【计数信号量初始化】
（1）该函数会在堆区初始化互斥锁
（2）该函数只能在main中调用，否则可能引发未定义错误
[参数：]
MaxCount		-->最大信号量
InitCount		-->当前初始信号量
*/
Semaphore_t* Semaphore_Init(int MaxCount,int InitCount);								//计数信号量初始化
/*
 【非阻塞型计数信号量申请】
（1）如果申请失败，该函数将立即返回执行之后的代码
[参数：]
Semaphore			-->信号量指针
*/
int  Semaphore_Applay_Non_Blocking(Semaphore_t* Semaphore);							//非阻塞型计数信号量申请
/*
 【阻塞型计数信号量申请】
（1）该函数在无法获取到信号量时会进入等待
（2）可以设置等待时间，时间以时间片为单位，比如等待1时间片
[参数：]
Semaphore			-->信号量指针
Block_Time			-->设置时间，当时间设置为0时，该函数将永久阻塞
*/
int Semaphore_Applay(Semaphore_t* Semaphore, int Block_Time);						//阻塞型计数信号量申请
/*
 【计数信号量归还】
（1）该函数能将计数信号量归还，注意任何人都可以归还信号量
[参数：]
Semaphore			-->信号量指针
*/
int Semaphore_Give(Semaphore_t* Semaphore);											//计数信号量归还

/***************************
*  动态内存分配
****************************/

#if HEAP_SCHEME == HEAP_SOLUTION_1  
/*-------HEAP_SOLUTION_1 开始-------*/
//申请动态空间
void* Ink_malloc(DYNAMIC_MEMORY_TYPE __size);
//更改动态空间
void* Ink_realloc(void* __ptr, unsigned short __original__size, unsigned short __predistribute__size);
//释放空间
int Ink_free(void* __ptr, DYNAMIC_MEMORY_TYPE __size);
//任务堆剩余空间统计（单位：字节）
int Task_Statistical_Free_Heap(void);
//用户堆剩余空间统计（单位：字节）
int User_Statistical_Free_Heap(void);
/*-------HEAP_SOLUTION_1 结束-------*/
#endif

/***************************
*  消息队列
****************************/
//struct Queue_t;
typedef struct Queue_t Queue_t;													//消息队列类型

typedef enum Message_Type Message_Type;											//消息类型
enum Message_Type {
	BLOCKING,	//阻塞型
	NON_BLOCKING//非阻塞型
};
/*
 【消息队列初始化】
（1）该函数会在堆区初始化消息队列
（2）该函数只能在main中调用，否则可能引发未定义错误
[参数：]
Queue_Count		-->最大队列数
Size			-->每个消息占用空间的大小
*/
//消息队列初始化
Queue_t* MessageQueue_Init(unsigned int Queue_Count,unsigned int Size);
/*
 【消息发送】
（1）该函数可以设置为阻塞型与非阻塞型
（2）阻塞型消息属于同步，只有当一个消息被发送切接收后才能进行下一次消息发送，否则陷入阻塞
（3）非阻塞型消息属于异步，当消息队列满了之后，就屏蔽后来的消息
[参数：]
Queue			-->队列的指针
Data			-->消息
type			-->发送类型
*/
//消息发送
int Message_Send(Queue_t* Queue ,void* Data, Message_Type type);
/*
 【消息接收】
（1）该函数可以设置为阻塞型与非阻塞型
（2）阻塞型消息属于同步，只有当一个消息被发送切接收后才能进行下一次消息发送，否则陷入阻塞
（3）非阻塞型消息属于异步，当消息队列满了之后，就屏蔽后来的消息
[参数：]
Queue			-->队列的指针
Data			-->消息
type			-->发送类型
*/
//消息接收
int Message_Receive(Queue_t* Queue, void* Data,Message_Type type);
/*
 【队列销毁】
（1）该函数会销毁整个队列
（2）当队列中存在消息，也会被一同销毁
[参数：]
Queue			-->队列的指针
*/
//销毁整个队列
int Queue_Delete(Queue_t* Queue);
/*
 【队列启动】
（1）该函数会让陷入休眠状态的队列重新启动
[参数：]
Queue			-->队列的指针
*/
//消息队列启动
void Message_Activate(Queue_t* Queue);
/*
 【队列启动】
（1）该函数会让活跃状态的队列休眠
[参数：]
Queue			-->队列的指针
*/
//消息队列休眠
void Message_Sleep(Queue_t* Queue);
#endif // !INKOS_H


/*                                                     【唱片机模型示意图】

																						SPC->Task_Ring(作为读取唱片的读头)
																						 ^
																						 |
							TOR (代表着唱片的部分区域									 |
							多个同一个优先级的TOR构成了一张完整的唱片）					 |
									   ^												 |
									   |												 |
                                       |                                                 |                          11111                             
                                       |                                                 |                      111101 111  ------------------------------------------------> SPC（代表唱片机的一层）                          
                                       |                                                 |                111111111010001                             
                                       |                                                 |          1111111111111    1111                             
                                       |                                                 |    1111111111111          1 11                             
                                       |                                                 |  111111111                1 11                             
                                       |                     11111111                    |11 111                     1 11                             
                                       |         1111111111000111110000000000001000111  11111111                     1 11                             
                                       1111111111     1111000000000000000000000000000111111011111111                11111                             
                                 111101111111111        11110000000000000000000000111 111111000000001111111111111  1111101                            
                              11000000000000000000000110111111    111     1111110000011100000000000000011      1111111111101111                       
                            100000000000000000000000000           1111           0000100000000000000000000     100101111111 11101                     
                       1111100000000000000000000010100001111111         11111110001111110100000000000000001            111111110                      
                    111    11110000101111111111        11110000000000000000000111    111   1111111111100001       11111   111100                      
                   10111 11111111111111          111111100000000000000000000000011111111        1111111111  11111    11111111111                      
                   1011       111111111111111111111000000000000000000000000000000000110101111111111111111111     11111111111                          
                    011                 11111111111100000000000000000000000000111101100111111    111111  11111111111000                               
                      111111111                     111111111111111111111111111111111  111   11111  111111111100011 111             ------------------------------------------------> SPC （代表唱片机的一层）                   
                               1111111111                         111111         1111   1111    111111111000000000111 011111111                       
                               10011000000011111111                           1111111111  111111111111110000000000011 00111111101                     
                          111100011111111111111011100000111111                   11111111111111000111110000000000001  1111110011                      
                     11111111111111 1111111110000110000000000000001111111        11010111100000000000000000000001111111111111                         
                    0111        111 000000000000000000000000000000000000000001111100001100000000000000000001111111100011                              
                    1111111111    111100000000000001111111111111100000000100000000011011111  11100000111111111000111111         ------------------------------------------------> SPC  （代表唱片机的一层）                      
                          1111111111111111111100000111      11111000000001100000000110000111 1111101111110000001111111011111                          
                             1100011111111111111111111111111111111100000000011111101100000111111111100010000000111111100011111111                     
                       11111111111111111111100000001111111111111111111111110111111111001111111110000111      1 1101  110011111101                     
                    111111     11100000000000000000000000110000111111      111111 1 11111110000001100000000111111001111111100011                      
                     1111        1100000000000001111000000100000000000000111111111111100000000000000000000011111100111111111                          
                        1111111   11100000000001111 11111111110000000000010000000001000000000111111111100001111111110011                              
                              11011111111111111111       1111111111000000000000000011000000000111  11100011111100001111          ------------------------------------------------> SPC （代表唱片机的一层）                      
                         111110011 1110101011111111   11111111111111000000000000011111110000011111111111110000000000010111111111                      
                     1111111111111000001010000000000011111111111111111000001110001 1100000111111111111111111100000000001111    11                     
                     11111      111100010100000000000000000000011111       11   1111110111111111100011111111111111111011   111111                     
                        111111111   111000000000000111111110000000000011111        111111110000000000000001111  111101111110111                       
                           1110000001111111111110001111    1111111110000000000001111100000000000000000000011111111011111111                           
                      1111111111100000000011111111111111111111111110000000000000001111110000000001100000001111111111001            ------------------------------------------------> SPC （代表唱片机的一层）                    
                    111        110000111111111111100111111111111111111000000001100  10000011111110000000111111110000110111111                         
                     1111111    11111111   1110001100000000000000111111         11  1101111111110000001111100000111011011111 111                      
                           11111111111111111110000000000111111110000000000111111  11111111   1111111111000000000111111011111   11                     
                           1000000011111111111111100000011     111111000000000000001000111111111111001111 11000000111111     1101                     
                         1100000101  11111000011111    111111111111100000000000000011011101111110000000111111111111011   1111001                      
                     11111111111111111111100000110000000111111111111111111111111111111111111000000000111110001111001111110000101                      
                     111   11111111110011110110010000000011111111111111            111111000000000000000000000000111110011101101                      
                     101111111111111110111101100000001111     1111000000100111111111110011100000000000111110011111000001 101110                       
                      1        111111111101111011100011111111111110000000111110000011111 11111111111111111111100011010111001110                       
                      1      111      111111111   11111111111111100000000111111111111011111111111111111111000011111100011111110                       
                     11    111 11111          11111 11111111111111111110000000001111100000011111111111000000001001 111110111110                       
                     11   11     1111   11  111111     1111  1         1111111111   1100111  111110000001110101101 11 111111100                       
                     11   11  1  10101     1   011    11111   1111             1111110111  11100001 11001111  11111111111111011                       
                     11    1    110001 1111 111011 1111 1111         11111           1 1110000001111111111       11111111011                          
                      1     111100001 11   1 1        111011 111         111111111111100001110001100  1    1 111111110000111111                       
                      11111    1111    111111111111     11        111111111    11110011000000111111111  111111111100000110001111111                   
                           1011111       11     1111111111  1111111      1111     1111100111111  1111111111111000011111110001111                      
                           11  1100001111              111  1   10   1   10101    111111001011  111111111100000000010000000111                        
                           11   1100000000001111            1111111      10101     1111111111   111111100000000000000001111                           
                            111110000000000000000001111           11   110001      111111111111111100000000000000111111                               
                               1111111110000000000000000001111      11100011 1    11011111111110000000000000011111                                    
                                          111110000000000000000001111        11   11000000000000000000000011111                                       
                                                1111111000000000000000001111      110000000000000000001111                                            
                                                        11111100000000000000011111000000000000000001111                                               
                                                              111100000000001   11110000000000011111                                                  
                                                                    111111001    1110100000011111                                                     
                                                                           1111111100000011111                                                        
                                                                              1111111111111   


*/
